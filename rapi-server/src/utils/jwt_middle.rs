use super::token::Token;
use poem::{Endpoint, Middleware, Request, Result};

pub struct JwtTokenMiddleware;

impl<E: Endpoint> Middleware<E> for JwtTokenMiddleware {
  type Output = JwtTokenMiddlewareImpl<E>;

  fn transform(&self, ep: E) -> Self::Output {
    JwtTokenMiddlewareImpl { ep }
  }
}

/// The new endpoint type generated by the TokenMiddleware.
pub struct JwtTokenMiddlewareImpl<E> {
  ep: E,
}

#[derive(Debug)]
pub struct User(pub Option<String>);

#[poem::async_trait]
impl<E: Endpoint> Endpoint for JwtTokenMiddlewareImpl<E> {
  type Output = E::Output;

  async fn call(&self, mut req: Request) -> Result<Self::Output> {
    let value = match req
      .headers()
      .get(&get_token_name())
      .and_then(|value| Some(value.to_str().unwrap().to_string()))
    {
      Some(token) => {
        let t = Token::parse(&token)?;
        Some(t.sub)
      }
      _ => None,
    };
    req.extensions_mut().insert(User(value));

    // call the inner endpoint.
    self.ep.call(req).await
  }
}

fn get_token_name() -> String {
  match std::env::var_os("TOKEN_NAME") {
    Some(t) => t.to_str().unwrap().to_string(),
    None => "token".into(),
  }
}


// use poem::{error::ResponseError, http::StatusCode};
// #[derive(thiserror::Error, Debug, Copy, Clone, Eq, PartialEq)]
// #[error("Token parsed error")]
// pub struct TokenParseError;

// impl ResponseError for TokenParseError {
//   fn status(&self) -> StatusCode {
//     StatusCode::INTERNAL_SERVER_ERROR
//   }
// }
